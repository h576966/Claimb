---
alwaysApply: true
---
# Claimb iOS Development Rules

You are an expert SwiftUI developer building Claimb - a League of Legends companion app for iPhone. Follow these rules for consistent, high-quality code.

## PROJECT CONTEXT
- **App**: Claimb - League of Legends companion app for iPhone
- **Architecture**: Local-first with SwiftData, no backend
- **Target**: Xcode 16, iOS 18 SDK, Swift 6.1+, SwiftUI (iOS-18 era APIs)
- **Runtime**: iOS 18+
- **Focus**: Post-game coaching, Champion Pool guidance, Performance analytics
- **Design**: Apple Watch-like interface with dark card-based layouts

## CORE PRINCIPLES

rule "search_first" {
  description = "Always search before implementing"
  when = "creating new features or modifying existing code"
  then = "SEARCH FIRST - Use codebase_search/grep/web_search tools until finding similar functionality or confirming none exists. Investigate deeply, be 100% sure before implementing."
}

rule "reuse_first" {
  description = "Reuse existing code before creating new"
  when = "implementing functionality"
  then = "REUSE FIRST - Check existing functions/patterns/structure. Extend before creating new. Strive to smallest possible code changes."
}

rule "simplicity_first" {
  description = "Eliminate over-abstraction and complexity"
  when = "designing architecture or refactoring code"
  then = "SIMPLICITY FIRST - Use direct integration over service layers. Prefer static loading over database queries. Use generics to eliminate code duplication. Challenge every abstraction - does it add real value?"
}

rule "dry_principle" {
  description = "Don't Repeat Yourself through smart patterns"
  when = "writing repetitive code"
  then = "DRY - Use factory patterns, generics, and direct model integration. If you see the same pattern 3+ times, abstract it. Eliminate boilerplate through language features."
}

rule "no_assumptions" {
  description = "Never assume, always verify"
  when = "writing code or making suggestions"
  then = "NO ASSUMPTIONS - Only use: files read, user messages, tool results. Missing info? Search then ask user."
}

rule "challenge_ideas" {
  description = "Challenge flawed approaches"
  when = "reviewing code or suggestions"
  then = "CHALLENGE IDEAS - If you see flaws/risks/better approaches, say so directly. Don't auto-agree with everything."
}

rule "be_honest" {
  description = "Be direct and honest"
  when = "providing feedback or suggestions"
  then = "BE HONEST - State what's needed/problematic, don't sugarcoat to please. Don't try to please me."
}

## SWIFTUI ARCHITECTURE

rule "navigation_patterns" {
  description = "Use modern navigation APIs"
  when = "implementing navigation"
  then = "Use NavigationStack for iPhone. Consider NavigationSplitView when adding iPad support. Replace NavigationView with NavigationStack (iOS 16+)."
}

rule "state_management" {
  description = "Follow SwiftUI state patterns"
  when = "managing state"
  then = "Use @State for local view state. Use @Observable (Swift 6) for new view models; fall back to ObservableObject only when you need objectWillChange. Use @Environment(\.modelContext) for SwiftData. Use @Query for simple fetches. Keep @MainActor on view models."
}

rule "ui_state_pattern" {
  description = "Use UIState enum for consistent state handling"
  when = "managing view state"
  then = "Use UIState<T> enum with cases: idle, loading, loaded(T), error(Error), empty(String). Use ClaimbContentWrapper for consistent UI state rendering. Example: ClaimbContentWrapper(state: viewModel.championState, loadingMessage: \"Loading...\", emptyMessage: \"No data found\", retryAction: { Task { await viewModel.loadData() } }) { data in /* content */ }"
}

rule "datamanager_pattern" {
  description = "Use DataManager with factory method for data operations"
  when = "loading data in views"
  then = "Use DataManager.create(with: modelContext) for consistent instantiation. DataManager handles request deduplication and returns UIState<T> for consistent state handling. Avoid direct service usage in views."
}

rule "view_models" {
  description = "Structure view models properly"
  when = "creating view models"
  then = "Use @MainActor @Observable view models with intents like load(), selectRole(_:), save(). No storage or networking in Views. Use DataManager for data operations. Example: @MainActor @Observable class ChampionDataViewModel { var championState: UIState<[Champion]> = .idle }"
}

rule "cancellation" {
  description = "Handle task cancellation"
  when = "performing async operations"
  then = "Debounce user text input. Cancel stale tasks on new input/teardown. Views must be resilient to canceled tasks."
}

## DESIGN SYSTEM

rule "color_usage" {
  description = "Use DesignSystem colors with variants"
  when = "using colors in UI"
  then = "Use DesignSystem.Colors only - never hardcode colors. Provide light/dark variants and semantic roles (primary/secondary/background/surface/overlay). Support Dynamic Type. No hex values in views."
}

rule "typography" {
  description = "Use DesignSystem typography with Dynamic Type"
  when = "styling text"
  then = "Use DesignSystem.Typography for all text styling. Support Dynamic Type. Headers: .largeTitle, .title, .title2, .title3. Body: .body, .bodyBold, .callout, .subheadline. Small: .footnote, .caption."
}

rule "spacing_layout" {
  description = "Use DesignSystem spacing and layout"
  when = "laying out UI elements"
  then = "Use DesignSystem.Spacing constants (xs: 4, sm: 8, md: 16, lg: 24, xl: 32, xxl: 48). Use DesignSystem.CornerRadius for rounded corners (small: 8, medium: 12, large: 16). Centralize spacing/radius in DesignSystem."
}

rule "card_ui" {
  description = "Follow card-based UI patterns"
  when = "creating UI layouts"
  then = "Use .claimbCard() modifier for surfaces. Optional blur/glass style behind feature flag for iOS 18 design language. Use dark card backgrounds with subtle borders. Apply proper shadows using DesignSystem.Shadows."
}

## DATA & CACHING

rule "swiftdata_usage" {
  description = "Use SwiftData properly"
  when = "working with data persistence"
  then = "Use @Model entities. Use @Query for simple fetches. Isolate complex queries into Repository services. Use @Environment(\.modelContext) for SwiftData access."
}

rule "http_caching" {
  description = "Implement proper caching strategy"
  when = "caching data"
  then = "Use URLCache for static Data Dragon responses. For Riot responses, prefer domain caching (SwiftData) keyed by (endpoint, params, version). Cache champion JSON/icons locally."
}

## API INTEGRATION

rule "riot_api_client" {
  description = "Use Riot API client properly"
  when = "making API calls"
  then = "All calls via RiotProxyClient through Supabase edge function. Rate limiting and exponential backoff handled by ProxyService. Don't hardcode fixed delays."
}

rule "rate_limiting" {
  description = "Implement proper rate limiting"
  when = "handling API rate limits"
  then = "Rate limiting handled by Supabase edge function proxy. Use ProxyService with exponential backoff retry logic for network failures. Don't hardcode fixed delays."
}

rule "data_dragon" {
  description = "Use Data Dragon service"
  when = "loading game data"
  then = "Use DataDragonService for static game data. Version-pinned fetch. Cache champion JSON/icons locally. Load champion data on first launch."
}

rule "error_handling" {
  description = "Handle errors comprehensively"
  when = "implementing error handling"
  then = "Implement comprehensive error handling at service layer. Use Result type for operations that can fail. Provide user-friendly error messages. Log errors for debugging purposes."
}

## LOGGING & UTILITIES

rule "structured_logging" {
  description = "Use ClaimbLogger for all logging"
  when = "adding logging"
  then = "Use ClaimbLogger.debug/info/warning/error with service parameter and metadata. Example: ClaimbLogger.info(\"Loading matches\", service: \"DataManager\", metadata: [\"summoner\": summoner.gameName]). No print statements in production."
}

rule "error_handler" {
  description = "Use ErrorHandler for user-friendly messages"
  when = "handling errors"
  then = "Use ErrorHandler.userFriendlyMessage(for: error) to convert technical errors to user-friendly messages. Use ErrorHandler.logError/logWarning/logInfo for structured logging."
}

rule "api_key_management" {
  description = "Use APIKeyManager for secure API key handling"
  when = "accessing API keys"
  then = "Use APIKeyManager.riotAPIKey for Riot API access. Check APIKeyManager.hasValidAPIKey before making requests. Never hardcode API keys in source code."
}

## UI STATES & UX

rule "ui_states" {
  description = "Handle all UI states properly"
  when = "creating views"
  then = "Every screen handles loading/empty/error/content states. Provide retry actions. Keep copy human and short. Use consistent loading indicators (ClaimbSpinner). Show meaningful error messages. Handle cancellation gracefully."
}

## CODE ORGANIZATION

rule "file_structure" {
  description = "Follow organized file structure"
  when = "organizing code"
  then = "Core/DesignSystem, Core/Utilities, Core/ViewModels, Core/Views. Models/. Services/{Riot, DataDragon, Storage, Coaching}. Features/{Champions, Coaching, KPIs, Onboarding}. ClaimbTests/ for tests. Resources/{Prompts, Strings}."
}

rule "naming_conventions" {
  description = "Use descriptive naming"
  when = "naming files and components"
  then = "Use descriptive names for views: ChampionView, PerformanceView, CoachingView. Use descriptive names for services: RiotProxyClient, ProxyService, DataDragonService, DataManager. Use descriptive names for models: Summoner, Match, Participant, Champion."
}

rule "code_comments" {
  description = "Add brief why comments"
  when = "writing code"
  then = "Use // MARK: - for section organization. Add brief 'why' comments for complex logic. Write lightweight ADRs. No code comments for obvious code - write self-explanatory code."
}

rule "file_length" {
  description = "Keep files manageable"
  when = "writing code"
  then = "Keep files ≤ ~300 lines. Extract subviews/components when needed. Split when it improves clarity."
}

## LEAGUE OF LEGENDS SPECIFIC

rule "champion_data" {
  description = "Handle champion data correctly"
  when = "working with champion data"
  then = "Use champion IDs for API calls, names for display. Handle 'Unknown Champion' cases gracefully. Load champion data from Data Dragon. Champion class mapping is integrated into Champion model."
}

rule "match_data" {
  description = "Parse match data correctly"
  when = "processing match data"
  then = "Parse match data correctly from Riot API. Handle different game modes and queues. Calculate performance metrics accurately. Use proper role classification."
}

rule "performance_analysis" {
  description = "Calculate performance metrics"
  when = "analyzing performance"
  then = "Use baseline data for performance comparison. Calculate role-specific metrics. Handle edge cases (division by zero, missing data). Provide meaningful performance insights."
}

## PROHIBITED ACTIONS

rule "no_hardcoded_values" {
  description = "Never hardcode values"
  when = "using colors, strings, or API keys"
  then = "DO NOT hardcode colors/strings in views. DO NOT hardcode API keys in source - use Keychain/build settings. Use DesignSystem.* only."
}

rule "no_blocking_operations" {
  description = "Don't block main thread"
  when = "performing operations"
  then = "DO NOT block main thread - use async/await everywhere. DO NOT forget error handling - always handle failure cases."
}

rule "no_legacy_apis" {
  description = "Use modern APIs"
  when = "implementing navigation and state"
  then = "DO NOT use NavigationView - use NavigationStack. DO NOT use ObservableObject for new view models - prefer @Observable."
}

## CODING STANDARDS

rule "plan_before_coding" {
  description = "Plan before implementing"
  when = "writing code"
  then = "Plan before coding, explain reasoning for complex suggestions. Keep imports alphabetically sorted. Keep code SOLID but simple - separation of concerns without over-engineering."
}

rule "test_critical_paths" {
  description = "Test critical functionality"
  when = "writing tests"
  then = "Write tests for critical paths only. Use AAA pattern with comments. Learn from examples. Test your tests and run lint checks."
}

rule "documentation_approach" {
  description = "Keep documentation light and contextual"
  when = "writing documentation"
  then = "Keep docs light unless explicitly requested. Focus on 'why' rather than 'what'. Write lightweight ADRs for architectural decisions. Maintain context for future developers."
}